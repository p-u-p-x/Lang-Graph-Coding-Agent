from typing import List, Optional
from pydantic import BaseModel, Field


class Plan(BaseModel):
    """Project plan generated by the planner agent"""
    project_name: str = Field(description="Name of the project")
    description: str = Field(description="Detailed description of the project")
    files: List[str] = Field(description="List of files needed for the project")
    technologies: List[str] = Field(description="Technologies and frameworks to be used")
    dependencies: List[str] = Field(description="External dependencies or libraries")
    structure: str = Field(description="Project structure and organization")


class ImplementationStep(BaseModel):
    """A single implementation step in the task plan"""
    task_description: str = Field(description="Detailed description of what to implement")
    filepath: str = Field(description="File path where this task should be implemented")
    dependencies: List[str] = Field(description="Tasks that must be completed before this one", default_factory=list)
    expected_output: str = Field(description="What should be produced by this task")


class TaskPlan(BaseModel):
    """Complete task plan generated by the architect agent"""
    implementation_steps: List[ImplementationStep] = Field(description="Ordered list of implementation steps")
    plan: Optional[Plan] = Field(description="Original project plan", default=None)


class CoderState(BaseModel):
    """State for the coder agent tracking progress"""
    task_plan: TaskPlan = Field(description="The complete task plan to implement")
    current_step_idx: int = Field(description="Current step index being implemented", default=0)


def planner_prompt(user_prompt: str) -> str:
    PLANNER_PROMPT = f"""
You are the PLANNER agent. Convert the user prompt into a COMPLETE engineering project plan.

User request:
{user_prompt}
    """
    return PLANNER_PROMPT


def architect_prompt(plan: str) -> str:
    ARCHITECT_PROMPT = f"""
You are the ARCHITECT agent. Given this project plan, break it down into explicit engineering tasks.

RULES:
- For each FILE in the plan, create one or more IMPLEMENTATION TASKS.
- In each task description:
    * Specify exactly what to implement.
    * Name the variables, functions, classes, and components to be defined.
    * Mention how this task depends on or will be used by previous tasks.
    * Include integration details: imports, expected function signatures, data flow.
- Order tasks so that dependencies are implemented first.
- Each step must be SELF-CONTAINED but also carry FORWARD the relevant context from earlier tasks.

Project Plan:
{plan}
    """
    return ARCHITECT_PROMPT


def coder_system_prompt() -> str:
    CODER_SYSTEM_PROMPT = """
You are the CODER agent.
You are implementing a specific engineering task.
You have access to tools to read and write files.

Always:
- Review all existing files to maintain compatibility.
- Implement the FULL file content, integrating with other modules.
- Maintain consistent naming of variables, functions, and imports.
- When a module is imported from another file, ensure it exists and is implemented as described.
    """
    return CODER_SYSTEM_PROMPT